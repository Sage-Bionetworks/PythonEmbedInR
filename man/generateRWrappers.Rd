% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PythonPkgWrapperUtils.R
\name{generateRWrappers}
\alias{generateRWrappers}
\title{Generate R wrappers for Python classes and functions}
\usage{
generateRWrappers(pyPkg, module = NULL, class = NULL, setGenericCallback,
  functionFilter = NULL, classFilter = NULL, functionPrefix = NULL,
  pySingletonName = NULL, transformReturnObject = NULL)
}
\arguments{
\item{pyPkg}{The Python package name}

\item{module}{The fully qualified name of a Python module}

\item{class}{The fully qualified name of a Python class}

\item{setGenericCallback}{The callback to setGeneric defined in the target R package}

\item{functionFilter}{Optional function to intercept and modify the auto-generated function metadata.}

\item{classFilter}{Optional function to intercept and modify the auto-generated class metadata.}

\item{functionPrefix}{Optional text to add to the name of the wrapped functions.}

\item{pySingletonName}{Optional parameter used to expose a set Python functions which are an object's
methods, but without exposing the object itself. If the \code{class} parameter is present then this must
be the name of a Python variable referencing an instance of the class. Otherwise, this must be NULL.
See example 4.}

\item{transformReturnObject}{Optional function to change returned values in R.}
}
\description{
This function generates R wrappers for Python classes and functions
in the given Python module
}
\details{
\itemize{
\item \code{module} can take the same value as \code{pyPkg}, or can be a module within the Python package.
\item \code{class} must be fully qualified name of a class within the Python package. When the \code{class} parameter
is present, the \code{module} parameter is ignored.
\item \code{setGeneric} function must be defined in the same environment that \code{generateRWrappers}
is called. See example 1.
\item \code{functionFilter} and \code{classFilter} are optional functions defined by the caller.
\item \code{functionFilter} takes as input the metadata for a generated function and either modifies it
or returns NULL to omit it from the set of generated functions. The metadata object is a list
having fields:\preformatted{'name': character
'args': named list having fields:
    'args': a list of the argument names (it may contain nested lists)
    'varargs':  character
    'keywords': character
    'defaults': character
'doc': character
'module':character
}

See example 2.
\item \code{classFilter} takes as input the metadata for a generated class and either modifies it
or returns NULL to omit it from the set of generated classes The metadata object is a list
having fields:\preformatted{'name': character
'constructorArgs': named list having fields:
    'args': a list of the argument names (it may contain nested lists)
    'varargs':  character
    'keywords': character
    'defaults': character
'doc': character
'methods':named list having fields:
    'name': character
    'doc': character
    'args': named list having fields:
        'args': a list of the argument names (it may contain nested lists)
        'varargs':  character
        'keywords': character
        'defaults': character
}

See example 3.
\item \code{transformReturnObject} is used to intercept and modify the values returned by the
auto-generated R functions.\code{transformReturnObject} will be applied to the returned values
from all generated functions. The transformation cannot depend on the function which generated
the returned value. See example 5.
}
}
\note{
\itemize{
\item \code{generateRWrappers} should be called at load time.
\item \code{generateRWrappers} and \code{generateRdFiles} must be called with corresponding parameters to ensure
all R wrappers has sufficient documentation.
}
}
\examples{
1. Generate R wrappers for all functions and classes in "pyPackageName.aModuleInPyPackageName"

callback <- function(name, def) {
  setGeneric(name, def)
}
PythonEmbedInR::generateRWrappers(
  pyPkg = "pyPackageName",
  module = "pyPackageName.aModuleInPyPackageName",
  setGenericCallback = callback)

2. Generate R wrappers for module "pyPackageName.aModuleInPyPackageName", omitting function "myFun"

myfunctionFilter <- function(x) {
  if (any(x$name == "myFun")) NULL else x
}
PythonEmbedInR::generateRWrappers(
  pyPkg = "pyPackageName",
  module = "pyPackageName.aModuleInPyPackageName",
  setGenericCallback = callback,
  functionFilter = myfunctionFilter)

3. Generate R wrappers for module "pyPackageName.aModuleInPyPackageName", omitting the "MyObj" class

myclassFilter <- function(x) {
  if (any(x$name == "MyObj")) NULL else x
}
PythonEmbedInR::generateRWrappers(
  pyPkg = "pyPackageName",
  module = "pyPackageName.aModuleInPyPackageName",
  setGenericCallback = callback,
  classFilter = myclassFilter)

4. Generate R wrappers for module "synapseclient.client.Synapse" without exposing the "Synapse" object

.onLoad <- function(libname, pkgname) {
  pyImport("synapseclient")
  pyExec("syn = synapseclient.Synapse()")
  # `pySingletonName` must be the name of the object defined in Python.
  generateRWrappers(pyPkg = "synapseclient",
                    class = "synapseclient.client.Synapse",
                    setGenericCallback = callback,
                    pySingletonName = "syn")
}

5. Generate R wrappers for module "pyPackageName.aModuleInPyPackageName", tranforming all returned values,
  and setting each returned object class name to "newName"
  
myTransform <- function(x) {
  # replace the object name
  class(x) <- "newName"
}
PythonEmbedInR::generateRWrappers(
  pyPkg = "pyPackageName",
  module = "pyPackageName.aModuleInPyPackageName",
  setGenericCallback = callback,
  transformReturnObject = myTransform)
}
