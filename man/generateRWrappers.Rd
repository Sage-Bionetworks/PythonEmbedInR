% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PythonPkgWrapperUtils.R
\name{generateRWrappers}
\alias{generateRWrappers}
\title{Generate R wrappers for Python classes and functions}
\usage{
generateRWrappers(pyPkg, module, setGenericCallback, functionFilter = NULL,
  classFilter = NULL, functionPrefix = NULL, pySingletonName = NULL,
  transformReturnObject = NULL)
}
\arguments{
\item{pyPkg}{The Python package name}

\item{module}{The fully qualified name of the Python module or class to be wrapped}

\item{setGenericCallback}{The callback to setGeneric defined in the target R package}

\item{functionFilter}{Optional function to intercept and modify the auto-generated function metadata.
Default NULL.}

\item{classFilter}{Optional function to intercept and modify the auto-generated class metadata.
Default NULL.}

\item{functionPrefix}{Optional text to add to the name of the wrapped functions.
Default NULL.}

\item{pySingletonName}{Optional parameter used to expose a set Python functions which are an object's
methods, but without exposing the object itself. If the `module` parameter is a class then this must
be the name of a Python variable referencing an instance of the class. If `module` parameter is not
a class then this must be NULL. Default NULL. See example 4.}

\item{transformReturnObject}{Optional function to change returned values in R. Default NULL.}
}
\description{
This function generates R wrappers for Python classes and functions
  in the given Python module
}
\details{
* `module` can take the same value as `pyPkg`, or can be a module within the Python package.
  The value that is passed to `module` parameter must be a fully qualified name.
  
* `setGeneric` function must be defined in the same environment that `generateRWrappers`
  is called. See example 1.
  
* `functionFilter` and `classFilter` are optional functions defined by the caller.

* `functionFilter` takes as input the metadata for a generated function and either modifies it
  or returns NULL to omit it from the set of generated functions. The metadata object is a list 
  having fields:
  ```
  'name': character
  'args': named list having fields:
      'args': a list of the argument names (it may contain nested lists)
      'varargs':  character
      'keywords': character
      'defaults': character
  'doc': character
  'module':character
  ```
  See example 2.
  
* `classFilter` takes as input the metadata for a generated class and either modifies it
  or returns NULL to omit it from the set of generated classes The metadata object is a list 
  having fields:
  ```
  'name': character
  'constructorArgs': named list having fields:
      'args': a list of the argument names (it may contain nested lists)
      'varargs':  character
      'keywords': character
      'defaults': character
  'doc': character
  'methods':named list having fields:
      'name': character
      'doc': character
      'args': named list having fields:
          'args': a list of the argument names (it may contain nested lists)
          'varargs':  character
          'keywords': character
          'defaults': character
  ```
  See example 3.
  
* `transformReturnObject` is used to intercept and modify the values returned by the
  auto-generated R functions.`transformReturnObject` will be applied to the returned values
  from all generated functions. The transformation cannot depend on the function which generated
  the returned value. See example 5.
}
\examples{
1. Generate R wrappers for all functions and classes in "pyPackageName.aModuleInPyPackageName"
```
callback <- function(name, def) {
  setGeneric(name, def)
}
PythonEmbedInR::generateRWrappers(
  pyPkg = "pyPackageName",
  module = "pyPackageName.aModuleInPyPackageName",
  setGenericCallback = callback)
```
2. Generate R wrappers for module "pyPackageName.aModuleInPyPackageName", omitting function "myFun"
```
myfunctionFilter <- function(x) {
  if (any(x$name == "myFun")) NULL else x
}
PythonEmbedInR::generateRWrappers(
  pyPkg = "pyPackageName",
  module = "pyPackageName.aModuleInPyPackageName",
  setGenericCallback = callback,
  functionFilter = myfunctionFilter)
```
3. Generate R wrappers for module "pyPackageName.aModuleInPyPackageName", omitting the "MyObj" class
```
myclassFilter <- function(x) {
  if (any(x$name == "MyObj")) NULL else x
}
PythonEmbedInR::generateRWrappers(
  pyPkg = "pyPackageName",
  module = "pyPackageName.aModuleInPyPackageName",
  setGenericCallback = callback,
  classFilter = myclassFilter)
```
4. Generate R wrappers for module "synapseclient.client.Synapse" without exposing the "Synapse" object
```
.onLoad <- function(libname, pkgname) {
  pyImport("synapseclient")
  pyExec("syn = synapseclient.Synapse()")
  # `pySingletonName` must be the name of the object defined in Python.
  generateRWrappers(pyPkg = "synapseclient",
                    module = "synapseclient.client.Synapse",
                    setGenericCallback = callback,
                    pySingletonName = "syn")
}
```
5. Generate R wrappers for module "pyPackageName.aModuleInPyPackageName", tranforming all returned values,
  and setting each returned object class name to "newName"
```
myTranform <- function(x) {
  # replace the object name
  class(x) <- "newName"
}
PythonEmbedInR::generateRWrappers(
  pyPkg = "pyPackageName",
  module = "pyPackageName.aModuleInPyPackageName",
  setGenericCallback = callback,
  transformReturnObject = myTranform)
```
}
