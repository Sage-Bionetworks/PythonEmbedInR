% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PythonPkgWrapperUtils.R
\name{generateRWrappers}
\alias{generateRWrappers}
\title{Generate R wrappers for Python classes and functions}
\usage{
generateRWrappers(pyPkg, module, setGenericCallback, modifyFunctions = NULL,
  modifyClasses = NULL, functionPrefix = NULL, pySingletonName = NULL,
  transformReturnObject = NULL)
}
\arguments{
\item{pyPkg}{The Python package name}

\item{module}{The name of the Python module to be wrapped.}

\item{setGenericCallback}{The callback to setGeneric defined in the target R package}

\item{modifyFunctions}{Optional function to modify the returned functions}

\item{modifyClasses}{Optional function to modify the returned classes}

\item{functionPrefix}{Optional text to add to the name of the functions}

\item{pySingletonName}{Optional singleton object in python}

\item{transformReturnObject}{Optional function to change returned values in R}
}
\description{
This function generate R wrappers for Python classes and functions
  in the given Python module
}
\details{
* `generateRdFiles` and `generateRWrappers` should be called with similar
  params to ensure all R wrappers has sufficient documentation.
  
* `module` can have the same value as `pyPkg` or a module within the Python package.
  The value that is passed to `module` parameter must be a fully qualified name.
  
* `setGeneric` function must be defined in the same environment that `generateRWrappers`
  is called. See example 1.
  
* `modifyFunctions` and `modifyClasses` are optional function defined by the caller.

* `modifyFunctions` takes an object with the schema: ('name', 'args', 'doc', 'module')
  and modifies the list of functions found under `module`. See example 2.
  
* `modifyClasses` takes an object with the schema: ('name', 'constructorArgs', 'doc', 'methods')
  and modifies the list of classes found under `module`. See example 3.
  
* `pySingletonName` is used to expose a set Python functions which are an object's methods,
  but without exposing the object itself. See example 4.
  
* `transformReturnObject` is used to intercept and modify the values
  returned by the auto-generated R functions. It takes an R6 object,
  and returned the modified R6 object. See example 5.
}
\note{
generateRWrappers should be called in .onLoad()
}
\examples{
1.
```
callback <- function(name, def) {
  setGeneric(name, def)
}
PythonEmbedInR::generateRWrappers(
  pyPkg = "pyPackageName",
  module = "aModuleInPyPackageName",
  setGenericCallback = callback)
```
2.
```
myModifyFunctions <- function(x) {
  if (any(x$name == "myFun")) NULL else x
}
PythonEmbedInR::generateRWrappers(
  pyPkg = "pyPackageName",
  module = "aModuleInPyPackageName",
  setGenericCallback = callback,
  modifyFunctions = myModifyFunctions)
```
3.
```
myModifyClasses <- function(x) {
  if (any(x$name == "myFun")) NULL else x
}
PythonEmbedInR::generateRWrappers(
  pyPkg = "pyPackageName",
  module = "aModuleInPyPackageName",
  setGenericCallback = callback,
  modifyClasses = myModifyClasses)
```
4.
```
.onLoad <- function(libname, pkgname) {
  pyImport("synapseclient")
  pyExec("syn = synapseclient.Synapse()")
  # `pySingletonName` must be the name of the object defined in Python.
  generateRWrappers(pyPkg = "synapseclient",
                    module = "synapseclient.client.Synapse",
                    setGenericCallback = callback,
                    pySingletonName = "syn")
}
```
5.
```
myTranform <- function(x) {
  # replace the object name
  class(x) <- "newName"
}
PythonEmbedInR::generateRWrappers(
  pyPkg = "pyPackageName",
  module = "aModuleInPyPackageName",
  setGenericCallback = callback,
  transformReturnObject = myTranform)
```
}
\seealso{
[generateRdFiles()]
}
